# 单调队列优化的DP问题

>  单调队列能解决的问题：滑动窗口求最值。

**扩展**：窗口长度不一定是固定的，只需要满足**首尾端点递增**即可。

- 原理（简单复习）：

暴力做法：每次窗口向后移动一格相当于队尾添加一个元素，队头弹出一个元素。每次求最值暴力枚举整个窗口中的数。时间复杂度：$O(NM)$（N为队列长度，M为窗口大小）。

- ==优化（单调队列的基本原理）：==

> **看一下队列当中什么元素不会被用到？**例如：数组`1 3 -1 -3 5 3 6 7`，求窗口长度为3时的每个窗口最小值。窗口1：`1 3 -1`，我们可以发现`1`和`3`永远不会被用到，因为`1`和`3`在`-1`的前面，且`1`和`3`是大于`-1`的，因此窗口在往后滑动的时候永远不会用到`1`和`3`。换句话说，只要`1`和`3`存在于窗口中，`-1`就一定也存在，只要`-1`存在，最小值的资格（也就是答案）就不可能轮到`1`和`3`。当我们把这些永远不会被用到的元素（冗余元素）去掉后，这个队列就是一个严格单调上升的序列。严格单调递增的序列有一个很好的性质，那就是序列中的第一个元素（也就是队头元素）永远都是最小的，因此求最小值的时候直接返回队头即可。
>
> **如何维护单调队列的单调性？**每次新增一个元素，从队尾往队头枚举，只要发现队尾元素比新增元素大，就将其从队尾弹出。直到队尾比新增元素小或队列为空，才把新增元素插入队尾。这样，就能保持队列的单调性不发生改变。

## DP分为两大类：

### 1. 朴素DP原理 —— 保证正确性

即闫氏DP分析法。

### 2. DP的优化 —— 对朴素DP做一个等价变形

要在保证正确性的基础上再做优化，单调队列优化就是这一部分的内容。

****

## 题目

![image-20231209232942149](image/1.9 单调队列优化的DP问题/image-20231209232942149.png)

#### 1. [最大子序和](https://www.acwing.com/problem/content/137/)

- 思路

> 闫氏DP分析法 => 闫氏最优化问题分析法

闫氏DP分析法**本质上是一个从集合角度来看最优化问题**，即在一个有限集合中求最值或者求个数。它不仅可以用来分析DP，还可以用来分析贪心问题。

状态计算 —— 集合划分：以“最后一个不同点”进行集合的划分，即根据子序列的终点来进行划分。

结尾是$a_1$的是第一类，结尾是$a_2$的是第二类，... ，结尾是$a_k$的是第k类，... ，一直到结尾是$a_n$的是第n类。总共分成n类，不重不漏。每次求出每一类的最大值，然后取max即可。

如何求以$a_k$结尾的连续子序列的和呢？ **前缀和**

所有以$a_k$结尾并且长度不超过m的连续子序列：$s[k] - s[k - j]（其中1\le j\le m）$，因为s[k]固定，因此需要找到一个最小的s[k-j]使得结果最大，这样就变成了在区间$[k - m, k]$中寻找最小值，并且这个区间是可以滑动的，因此就可以想到用单调队列来求解。

- [代码](E:/codes/C++/AcwingTest/最大子序和.cpp)

****

#### 2. [旅行问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1600)

- 思路

首先**破环成链**，然后每个点上的数值等于该点提供的油量和到下一个点所需的距离之差，即$s[i] = p[i] - d[i]$，然后判断从点$i$到达链上的下一个点$i$之间的所有前缀和是否大于等于0，是则可以到达，否则不能到达。本题的任务是：判断以每个车站为起点能否按条件成功周游一周。也就是说判断每个点到达下一个点之间的前缀和的最小值是否大于等于0。也就是求一个区间为n的窗口内的最小值，即**单调队列问题**。

因为，是个环且起点任意，因此顺时针扫描每个点做一遍，把符合要求的点都进行标记；再逆时针扫描，把符合要求的点进行标记，然后判断只要该点被标记过一次就说明该点符合要求。

> 顺时针枚举顺序：从后往前扫描。在区间$[i,i+n-1]$中找出最小值$s[j]$使得$s[j] - s[i - 1] \ge 0$。
>
> 逆时针枚举顺序：从前往后扫描。

- [代码](E:/codes/C++/AcwingTest/旅行问题.cpp)

****

#### 3. [烽火传递](http://ybt.ssoier.cn:8088/problem_show.php?pid=1602)

- 思路

> 状态表示：f[i]
>
> 1. 集合：表示所有考虑到第i个烽火台，并且点燃第i个烽火台的合法方案
> 2. 属性：Min
>
> 状态计算：
>
> 在代价范围为$[i-m,i)$之间枚举，取最小值。
>
> $f[i] = min\{f[j]\} + w_i（其中 i-m \le j< i）$（即在一个长度为$m-1$的区间内找最小值），滑动窗口求最值，因此就可以想到使用单调队列优化来降低时间复杂度。

- [代码](E:/codes/C++/AcwingTest/烽火传递.cpp)

****

#### 4. [绿色通道](https://www.acwing.com/problem/content/1092/)

- 思路

本题是上一题的拓展：需要二分答案。

如何寻找二分切入点？

<img src="image/1.9 单调队列优化的DP问题/image-20231215141440325.png" alt="image-20231215141440325" style="zoom:67%;" />

> 当t满足时，t右边的所有点都能满足，t左边的还不确定，因此继续枚举t所在的点，每次折半寻找t的位置。

因此这道题就变成了，在空题段长度不超过每次二分出来的值$limit$的情况下，需要最少花费的时间是多少？

转换成上一题：把每个空题看作是一个`烽火台`，在不超过`limit`的情况下，求点火的最小代价。

- [代码](E:/codes/C++/AcwingTest/烽火传递.cpp)

****

#### 5. [修剪草坪](http://ybt.ssoier.cn:8088/problem_show.php?pid=1599)

- 思路

> 状态表示：f[i]表示所有考虑前i头牛，且合法（没有选超过连续K头奶牛）的方案的最大值。
>
> 状态计算 —— 以是否选第i头牛划分出两个集合
>
> 不选第i头牛：$f[i - 1]$
>
> 选第i头牛：继续划分——从i开始往前的连续一段牛的长度（包含第i头牛），可以划分成k个集合：长度为1，2，3，……，k
>
> 假设选了长度为$x$的连续一段的牛，那么选的牛的编号为：$i-x+1,i-x+2,\cdots,i-1,i$ 。并且编号为$i-x+1$这头牛的前面一头牛（编号为$i-x$）不能选，即前面的牛的编号取值范围为$1\le y \le i-x-1$，那么这样就可以分成`变`和`不变`两个部分：
>
> - `变`的部分，即编号范围[1, i-x-1]的这些牛可以随便选，$f[i - x - 1]$
> - `不变`的部分，即编号范围[i-x+1, i]的这些牛固定，$s_i - s_{i-x}$
>
> 因此，令$j=x$，则有：
>
> $f[i] = f[i - j - 1]+s_i - s_{i-j} = max\{f[i-j-1]-s_{i-j}+s_i\}（其中s_i固定，1\le j \le k）$
>
> 滑动窗口求极值问题，可用单调队列来优化。
>
> 分析边界：令$g(x)=f(x-1)-s_{x}$
>
> $当x=0时，g(0) = f(-1)-s_0 = f(0)-s_0=0（其中s_0=0,f(-1)=f(0)=0）$
>
> 这道题中$f(-1)$是用意义的，就等于$f(0)$，需要特殊处理，值就是为0。
>
> 而在别的题目中可能就不等于0了，需要注意一下这一点！

- [代码](E:/codes/C++/AcwingTest/修剪草坪.cpp)

****

#### [理想的正方形](http://ybt.ssoier.cn:8088/problem_show.php?pid=1604)

- 思路

暴力思路：枚举每个长度为n的正方形，求出它的最大值和最小值之差，取枚举完的最小值就是答案。

优化思路：预处理每一个长度为n且高度为1的矩形的最大值，将其放在该矩形最右侧。一直枚举到边界，处理完后，每个长度为n的正方形内部的最右侧那一列都是该正方形中每一行上的最大值，接下来同理预处理每一个高度为n且长度为1的矩形最大值。预处理完毕，每个长度为n的正方形的内部的右下角那个格子里存放的就是该正方形的最大值。同理可以预处理最小值。其中预处理过程使用单调队列优化。

时间复杂度：$O(n)$

具体思路：https://www.acwing.com/solution/content/68010/

- [代码](E:/codes/C++/AcwingTest/理想的正方形.cpp)

****

