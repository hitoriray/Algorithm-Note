# 树形DP

#### 1. [树的最长路径](https://www.lintcode.com/problem/1469/)

<img src="image/1.7 树形DP/image-20231206161445062.png" alt="image-20231206161445062" style="zoom:100%;" />

- 思路

树的最长路径也被称为 “==树的直径==”。

这道题是一般情况下的树的直径问题，而**经常在算法题中考到的是特殊情况下的树（没有边权的树）的直径问题**。没有边权的树（可以是多叉树）的直径的定义就是求经过边的数量最多的一条路径。每棵树的直径不唯一，求出一条即可。例如：<img src="image/1.7 树形DP/image-20231206163804130.png" alt="image-20231206163804130" style="zoom:50%;" />

****

> 那对于特殊情况即没有边权的树的直径要怎么求呢？有很多种做法，最常用的做法是：
>
> 1. 任取一点作为起点，找到距离该点最远的一点u。【dfs或==bfs(推荐)==】
> 2. 再找到距离u最远的一点v。【dfs或==bfs(推荐)==】
>
> 那么u和v之间的路径就是一条直径。（用bfs的原因是防止dfs暴栈）

> ==证明==：任取一点a，找到距离a最远的一点u，证明u一定是某一条直径的一个端点。

1. 当bc与au没有交点时，假设$b\to c$是一条直径，那么一定有$b\to u \ge b\to c$，即$b\to u$一定是一条直径。u一定是直径的一个端点，证毕。

<img src="image/1.7 树形DP/image-20231206165025842.png" alt="image-20231206165025842" style="zoom:70%;" />

2. 当bc与au有交点时，因为u是距离a最远的一点，因此$xu \ge xc$，所以$bu \ge bc$。证毕。<img src="image/1.7 树形DP/image-20231206165519170.png" alt="image-20231206165519170" style="zoom:67%;" />

****

回到本题，如果每条边的权重不是1了，该怎么求树的直径呢？**如果边的权值不能确定大小以及正负，就要用==树形DP==来做。**

具体思路参考：https://www.acwing.com/file_system/file/content/whole/index/content/2826773/

- [代码](E:/codes/C++/AcwingTest/树的最长路径.cpp)

****

#### 2. [树的中心]()

<img src="image/1.7 树形DP/image-20231206173549805.png"/>

- 思路

分别求出来每个点到其他所有点的最长距离是多少，然后在所有最长距离中求出最小值即可。

如何求一个点到其他所有点的最长距离？

分为两大类：

1. 求出该节点向下走的最长距离，利用上一题的思路直接求出最长距离dist即可。
2. 求出该节点向上走的最长距离：

>首先该节点到父节点的距离已经确定，要求的就是从父节点能走的最长距离（分为两大类）
>
>1. 从父节点向上走的最长距离。
>2. 从父节点向下走的最远距离，若这条最远距离包含刚刚转移过来的子节点，那么就改成选择次长距离。

因此要做两次dfs：第一次由子节点更新父节点；第二次由父节点更新子节点。

<img src="image/1.7 树形DP/image-20231206184921553.png" alt="image-20231206184921553" style="zoom:67%;" />

> 注意：根节点和叶子节点需要特殊处理，详见代码。

- [代码](E:/codes/C++/AcwingTest/树的中心.cpp)

****

#### 3. [数字转换](http://ybt.ssoier.cn:8088/problem_show.php?pid=1577)（树的最长路径）

- 思路

因为一个数x的约数之和y是固定的，因此，若x与y可以相互转换，那么就在x和y之间连一条无向边，并且让y作为x的父节点。这样，每个点最多只会存在一个父节点。将1~n之间的数每个符合条件的x，y都建立这样一条边，那么就会构成森林。那么这个问题就变成了，**在所有树中找到一个长度最长的路径**。

另一个考点：如何快速地把这些符合条件的边找出来？

1. 可以利用约数之和公式，时间复杂度$O(n\sqrt n)$：这道题可以AC，但是不好扩展，数据过大（$N=10^5或10^6$）就会TLE。

2. **也可以利用线性筛法的思想，时间复杂度$O(n\log n)$：求出x的倍数，即x是哪些数的约数。**

```c++
// 线性筛法求x是哪些数的约数
for (int i = 1; i <= n; i ++ )
    for (int j = 2; j <= n / i; j ++ )
```

> 当然，这道题也可以用特殊情况的树的直径问题解法来做，因为这道题所有边的权重都是1。

- [代码](E:/codes/C++/AcwingTest/数字转换.cpp)

****

#### 4. [二叉苹果树](http://ybt.ssoier.cn:8088/problem_show.php?pid=1575)（树形DP + 有依赖的背包问题）

- 思路

这道题其实是有依赖的背包问题的简化版。把每个点看作是一个**物品**，若要保留节点x，就必须要保留它的父节点y。**边(x,y)的权重可以看作是x的价值，并且x的体积是1，背包容量是Q。**那么，这道题就变成了“有依赖的背包问题”。

1. 从分组背包问题的角度考虑：

> f[i, j]表示在以i为根的子树中选j条边的最大价值。
>
> 把每个根节点i的子树s1, s2看作是分组背包问题里的一组，每一组物品里枚举选择的边数，但是这个边数不能超过j-1，因为要保留从根节点i到子树的那一条边。例如：物品组s1的选择方案如下：
>
> 物品1：选择0条边，f[s1, 0]，其中价值为f[s1, 0] + w，体积为n+1即0+1=1。
>
> 物品2：选择1条边，f[s1, 1]，价值：f[s1, 1] + w，体积：2。
>
> ......
>
> 物品j-1：选择j-1条边，f[s1, j - 1]，价值：f[s1, j - 1] + w，体积：j。

<img src="image/1.7 树形DP/image-20231206232403548.png" alt="image-20231206232403548" style="zoom:75%;" />

- [代码](E:/codes/C++/AcwingTest/二叉苹果树.cpp)

2. 从以子物品体积的集合划分角度来考虑，时间复杂度更低！这个代码才能AC一本通oj上的题。

具体思路见：https://www.acwing.com/solution/content/65600/

****

#### 5. [战略游戏](https://www.acwing.com/problem/content/325/)（树形DP + 状态机模型）

>与“没有上司的舞会”的区别：
>
>- 没有上司的舞会：每条边上最多选择一个点。求最大权值。（树形DP，每个状态是一个状态机）
>- 战略游戏：每条边上至少选择一个点。求最小权值。（也是树形DP，每个状态是一个状态机）

- [思路](https://www.acwing.com/solution/content/66365/)

> 状态表示：f[i, j\](j = 0,1)
>
> 1. 集合：所有在以i为根的子树中选，且点i的状态是j的所有选法
> 2. 属性：Min
>
> 状态计算：
>
> f[i, 0]表示所有以i为根的子树且不选第i个点的方案。那么就要选点i的所有子树的根节点即以i为根节点的所有孩子节点s1,s2,...。==f[i, 0] = f[s1, 1] + f[s2, 1] + ...==
>
> f[i, 1]表示选上点i的方案。那么点i的孩子节点可选可不选，==f[i, 1] = min{f[s1, 0], f[s1, 1]} + min{f[s1, 0], f[s1, 1]} + ...==

- [代码](E:/codes/C++/AcwingTest/战略游戏.cpp)

****

#### 6. [皇宫看守](http://ybt.ssoier.cn:8088/problem_show.php?pid=1579)（树形DP + 状态机模型）

- 思路

本题的状态机有3种状态：

1. **f[i, 0]** 表示**点i没有摆放警卫且被其父节点看到**的所有方案中的最小花费。$f[i,0]=\sum min\{f[j,1], f[j,2]\}（其中j为i的所有子节点）$ ，因为i被其父节点看到，说明i上没有警卫，因此i的所有子节点只能是被它们的各自的子节点看到或者自身上摆放一个警卫。

2. **f[i, 1]** 表示**点i没有摆放警卫且被其子节点看到**的所有方案中的最小花费。$f[i,1]=\underset{k}{Min}\{f[k,2]+\underset{j\ne k}{\sum}min\{f[j,1],f[j,2]\} \}$，枚举是哪一个子节点k看到的点i，然后加上除了点k之外的其他i的子节点的最小花费之和（因为i已经可以被k看到了，因此i的其他子节点要么被它们各自的子节点看到，要么自己身上摆放警卫，取最小值即可）。

3. **f[i, 2]** 表示**在点i上摆放警卫**的所有方案的最小花费。$f[i,2]=\sum min\{f[j,0],f[j,1],f[j,2]\}$，在i上摆放警卫，此时i的所有孩子都会被i看到，因此它们身上的状态可以是三种状态中的任意一种，取最小值即可。

- [代码](E:/codes/C++/AcwingTest/皇宫看守.cpp)

****

