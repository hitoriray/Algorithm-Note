# 状态机模型

- 状态机的概念：https://baike.baidu.com/item/%E7%8A%B6%E6%80%81%E6%9C%BA/6548513 或 https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA

- 用途：

1. 编译。例如：C++，Java，Python在编译的时候是用一个状态机的模型去编译的。

2. 游戏。例如：UE中人物的动作就是状态机模型。
3. ...

**状态机描述的是一系列有序的事件。**

把之前状态计算中的点扩展成过程。

<img src="1.4 状态机模型/image/image-20231130103603061.png" alt="image-20231130103603061" style="zoom:50%;" />

### 应用题

#### 1. [大盗阿福](http://ybt.ssoier.cn:8088/problem_show.php?pid=1301)

- 思路

>f[i]:表示抢劫前i家店铺的最大收益。

传统分析方式：<img src="1.4 状态机模型/image/image-20231130104619845.png" alt="image-20231130104619845" style="zoom:50%;" />

**状态机分析方式**：将f[i]分解成两个状态：f[i, 0]和f[i, 1]（0表示不选最后一个店铺，1表示选最后一个店铺）。

f[i, 0]根据下一个店铺能不能选分成两条路线：不选：0->0，选：0->1

f[i, 1]的下一个店铺只能不选：1->0

<img src="1.4 状态机模型/image/image-20231130105553206.png" alt="image-20231130105553206" style="zoom:67%;" />

这样这个状态机就分成了3条边，每一步走一条边。

**任何一个抢劫的方案都可以对应状态机的一个走法。反过来，状态机中任何一个长度是n的走法都可以对应到原问题的某一个抢劫方案。**

<img src="1.4 状态机模型/image/image-20231130110505831.png" alt="image-20231130110505831" style="zoom:80%;" />

- [代码](E:/codes/C++/AcwingTest/大盗阿福.cpp)

****

#### 2. [股票买卖IV](https://www.acwing.com/problem/content/1059/)

- 思路

一次交易两个状态：（边表示钱的变化）

1. 手中有股票

   - 下一天选择继续持有（=>手中有股票），边的权重是0（因为没有任何收益）。

   - 下一天选择卖出股票（=>手中无股票），边的权重是+w（w表示手中股票的价格）。

2. 手中无股票

   - 下一天选择不买入股票（=>手中无股票），边的权重是0。

   - 下一天选择买入股票（=>手中有股票），边的权重-w。

<img src="1.4 状态机模型/image/image-20231130112743397.png" alt="image-20231130112743397" style="zoom: 67%;" />

> 状态表示：
>
> 1. 集合：
>
> ​	f[i, j, 0]表示已经进行到第i天，并且正在进行第j次交易，且手中无股票的所有方案的集合。
>
> ​	f[i, j, 1]表示已经进行到第i天，并且正在进行第j次交易，且手中有股票的所有方案的集合。
>
> 2. 属性：Max
>
> 状态计算：
>
> f[i, j, 0] = max(f[i - 1, j, 0], f[i - 1, j, 1] + w[i])
>
> f[i, j, 1] = max(f[i - 1, j, 1], f[i - 1, j - 1, 0] - w[i])

> 关于初始化：f[i, 0, 0] = 0, f[i, 0, 1] = -∞（i: 0~n）
>
> 初始化成0表示进行到第i天且不进行任何交易且手中无股票的收益为0。并且进行到第i天且不进行任何交易且手中有股票的这种状态本身就不存在，因此初始化成负无穷表示不存在这种状态。初始化成无穷是因为我们不希望从这个状态转移过来，且题目要求的是最大值，因此初始化成负无穷，若求最小值则初始化成正无穷。

- [代码](E:/codes/C++/AcwingTest/股票买卖IV.cpp)

****

#### 3. [股票买卖V](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

- 思路

这题我们发现两个状态不够用了，因此要新增一个状态：冷冻期

3个状态：1.手中有股票；2.手中无股票的第1天（冷冻期）；3.手中无股票的第i天(i$\ge$2)（非冷冻期）。

状态转移：<img src="1.4 状态机模型/image/image-20231130122521060.png" alt="image-20231130122521060" style="zoom:80%;" />

状态机的入口：手中无股票（非冷冻期）

状态机的出口：手中无股票（冷冻期）、手中无股票（非冷冻期）

> 关于初始化：把入口初始化成0，其他的状态都初始化成负无穷。  

- [代码](E:/codes/C++/AcwingTest/股票买卖V.cpp)

****

#### 4. [设计密码](https://www.acwing.com/blog/content/30/)

- [思路](https://www.acwing.com/solution/content/55449/)

这道题的状态更多，有`m + 1`个（m是模板串T的长度）

把next数组中的j所在位置看作一个状态，且这个状态不能到达m处，因为一旦到达m处就表示匹配成功，不符合题意。

根据原串的第i个字符与模板串的第j+1个字符的不同，取决于第i个字母是什么，可以划分成`a-z`总共26条边。

一共有m+1个状态，每个状态有26条边，因此可以建立出这样一个状态机。入口是`j=0`，每次沿着一条边走，限制是不能走到`m`这个点。走n步一共有多少中不同的路线就是本题的答案。时间复杂度：$O(26\times N^2)$。

预处理的时间复杂度也是$O(26\times N^2)$，所以整体时间复杂度是$O(26\times N^2)$，但由于本题的N=50非常小，因此不用预处理，直接暴力，时间复杂度$O(26\times N^3)$。

> f[i, j]表示当前已经写到了原字符串的第i个字母，且当前已经跳到了KMP里第j个状态的所有方案。

- [代码](E:/codes/C++/AcwingTest/设计密码.cpp)

****

#### 5. [修复DNA]()（AC自动机）

> AC自动机 = Tire + KMP

