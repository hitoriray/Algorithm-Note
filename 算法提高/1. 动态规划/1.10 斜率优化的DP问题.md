# 斜率优化的DP问题

优化的过程与分析的过程毫无关系，优化只是对代码做**等价变形**，从而降低时间复杂度。

斜率优化的题目一般比较复杂，仔细想也知道，简单的题目还用得到斜率优化吗？

废话少说，直接看题目：（下面这些题目基本把该类问题都涵盖了）

## 1. [任务安排1](https://www.acwing.com/problem/content/302/)

- 思路

一旦增加了一个启动时间S，那么对于在增加处后面的所有任务的完成时刻都会后移S秒。

**本题的重要思想**：**把当前这批任务（区间）的启动时间所带来的总花费提前算到当前区间里面去。**即$S\times (C_{j+1}+C_{j+2}+\cdots + C_n)$ 。这样就不用再考虑该启动时间S对后面的其他区间的影响了。

基于这个思想，分析状态表示和状态转移方程：

> 状态表示：f[i]（序列DP，一维即可）
>
> 1. 集合：将前i个任务处理完的所有方案的集合
> 2. 属性：Min
>
> 状态计算：
>
> 划分依据（找不同点）：最后一批任务是哪一批？即最后一批任务的`长度`或`起点`或`前一个位置是什么`。这边以最后一批任务的`前一个位置`来进行划分。
>
> 最后一批任务是 `j` $(j < i)$，那么最后一批任务就是从`j`到`i`。取其中的最小值更新$f[i]$
>
> 推到这个转移方程才是难点：
>
> 从`1~j`之间可以任选，即`f[j]`，从`j+1~i`是最后一批任务，即$SumT_i\times (SumC_i-SumC_j) + S\times (SumC_N-SumC_j)$
>
> 所以有：
>
> $f(i)=min\{f(j)+SumT_i\times (SumC_i-SumC_j) + S\times (SumC_N-SumC_j)\}（0\le j \le i-1）$

**时间复杂度：$O(n^2)$**

- [代码](E:/codes/C++/AcwingTest/任务安排I.cpp)

****

## 2. [任务安排II](https://www.acwing.com/problem/content/303/)

在第一题的基础上扩大了N的范围。

- 思路

考虑如何进行优化？

> 将上述转移方程中的$f(j)$看成$y$，$SumC_j$看成$x$，然后对方程进行变形，得到：
>
> $f(i)=f(j)-(SumT_i+S)\times SumC_j + SumT_i\times SumC_i + S\times SumC_N$ ，即：
>
> $f(i)=y-kx + c$ 即 $y=kx+f(i)-c$
>
> $f(j)=(SumT_i+S)\times SumC_j - SumT_i\times SumC_i - S\times SumC_N + f(i)$
>
> 将与$j$有关的看作变量，则有：
>
> $令y=f(j),x=SumC_j，则斜率k=(SumT_i+S),截距b= f(j) - SumT_i\times SumC_i - S\times SumC_N$
>
> 得到了一个二元一次方程（直线方程）。
>
> 由题意可知：k是一个正整数，并且不等于正无穷，因此**斜率的角度$0^{\circ} <\theta <90^{\circ}$。**
>
> $\because$ 变量`j`的取值范围：$[0, i-1]$
>
> $\therefore$ 就能得到一些点：$(f(0), SumC_0),(f(1), SumC_1,\cdots,(f(i-1),SumC_{i-1}))$
>
> 我们的目标是最小化$f(i)$，且公式中除了$f(i)$外的其他常数都是可以算出来的。当`i`固定后，斜率也是固定的，因此有：
> $$
> 当j=0（对应点(f(0),SumC_0)）时，整个方程中就只有f(i)是未知的，求出f(i)得到一个数。\\
> 由于截距里面的f(i)是正的，因此截距越大，f(i)越大，截距越小，f(i)越小。\\
> 同理，当j=1,2,\cdots,i-1时，都会得到一个对应的f(i)。\\
> 目标求出它们之中截距最小的那个。\\
> 把这些点：(f(0), SumC_0),(f(1), SumC_1,\cdots,(f(i-1),SumC_{i-1}))在图中标记出来\\
> $$
> 思路：将一个斜率固定的直线从负无穷向上平移，第一次碰到其中的某一个点时的截距最小，这么多点中一定会有一些点不会作为答案输出，因此还要用到单调队列的思想把这些没用的点及时删除。
>
> 什么样的点永远不会作为最小值输出呢？
>
> 对于不同的`i`斜率也不同，因此最靠外围的点一定不能被删掉，其他的点则可以被删掉。
>
> 思路：任选两个点作一条直线，把该直线上方的点全部删掉。（与凸包的定义是一样的）

<img src="image/1.10 斜率优化的DP问题/image-20231224131722032.png" alt="image-20231224131722032" style="zoom:67%;" />

删掉永远不会用到的点之后：

<img src="image/1.10 斜率优化的DP问题/image-20231224131758851.png" alt="image-20231224131758851" style="zoom:67%;" />

可以发现，所有会被用到的点构成一个**凸包的下边界**。

**因此，我们在做的时候只需要维护凸包的下边界这些点即可。（斜率优化的核心思想）**

到这里还没完，我们要思考凸包上哪个点才能作为最小值输出？

<img src="image/1.10 斜率优化的DP问题/image-20231224132132579.png" alt="image-20231224132132579" style="zoom:67%;" />

对凸包上每两个点之间求出一个斜率$k_i$，对于一个给定的直线斜率$k$。

第一个斜率大于`k`的点可以作为最小值输出。

如上图所示，$k1 < k < k2$，因此$k2$所在的点也就是从左往右数第二个点是答案点。

**因为凸包上所有点的斜率是单调的，因此就相当于在一个单调的队列中找到第一个大于某一个斜率$k$的点，有很多种方式可以求出这个点。**（二分）

同时在我们这个问题里面有这些性质：（利用这些性质可以做到$O(1)$的时间复杂度维护凸包）

1. 斜率$k$单调递增的（因为$SumT_i$单调递增，$S$不变），新加的点的横坐标单调递增。（因为$SumC_i$单调递增，也就是方程中的$x$单调递增）
   1. **在查询时，可以将队头小于等于当前斜率的点全部删掉。**（因为斜率一直递增，小于当前斜率的点在未来也绝对不会被用到）
   2. **在插入时，将队尾所有不在凸包上的点全部删掉。**（实时维护凸包的性质）

① $\frac{f(2)-f(1)}{SumC_2-SumC_1}\le SumT_i + S$ （假设$f(2)和f(1)$为队头点）：将队头小于等于当前斜率的点全部删掉。（把不会用到的点全部删掉）

② $\frac{f_{tt} - f_{tt-1}}{SumC_{tt}-SumC_{tt-1}} \ge \frac{f_i-f_{tt-1}}{SumC_i-SumC_{tt-1}}$ ：将队尾所有不在凸包上的点全部删掉。（维护凸包的性质）

或者 $\frac{f_{tt} - f_{tt-1}}{SumC_{tt}-SumC_{tt-1}} \ge \frac{f_i-f_{tt}}{SumC_i-SumC_{tt}}$ 也行，两种方法都可以。

- [代码](E:/codes/C++/AcwingTest/任务安排II.cpp)

****

## 3. [任务安排III](https://www.acwing.com/problem/content/304/)

与上一题的唯一区别：T可以是负数的。

- 思路

2. 斜率$k$不再具有单调性（因为$SumT[]$数组不一定单调递增），但是新加的点的横坐标仍然单调递增（因为$SumC[]$数组仍然单调递增）。
   1. 在**查询**时，不能像上题那样`将队头小于等于当前斜率的点全部删掉`，只能用**二分**。
   2. 在**插入**时，与上题类似，**将队尾所有不在凸包上的点全部删掉**。

时间复杂度由$O(n)$变成$O(\log n)$，其他的都一样。

- [代码](E:/codes/C++/AcwingTest/任务安排III.cpp)

****

> 扩展：如果换成C变成负数了呢？思路：把`x`和`y`互换，正的看成`x`，负的看成`y`，就可以用类似的方式来做。如果都是负数的呢？需要用平衡树来动态维护一个有序序列。NOI有可能考到。（NOI.2007 货币兑换）

****

## 4. [运输小猫](https://www.acwing.com/problem/content/305/)

- 思路

<img src="image/1.10 斜率优化的DP问题/image-20231224150200581.png" alt="image-20231224150200581" style="zoom:67%;" />

将$d[i]$转换成关于$d_i$的前缀和数组，d[i]表示1~i的距离。

目标：$S_i\ge t_i - d_i=A_i$，当且仅当饲养员出发时间$S_i-A_i\ge0$时，才能接到第$i$只小猫，因为一个饲养员可以接无穷多只小猫，因为将每只小猫对应的$A_i$递增排序，计算出饲养员接到所有小猫时，使得小猫的等待时间最笑。如上图所示，假设第一个饲养员负责接$A_1,A_2,A_3$对应的3只小猫，此时这三只小猫的总共等待时间为：$A_3-A_1+A_3-A_2+A_3-A_3=A_3\times 3 - (Sum_3-Sum_0)$。（Sum表示A的前缀和数组）

就这样经过层层转换，该题变成了：

给定一个有序序列，最多把该序列分成P组，求出每组的$A_r\times (r-l+1) - Sum_r - Sum_l$之和最小。

> DP分析法：
>
> 由于本题最多有P组，因为需要两个维度。
>
> 状态表示：$f[j, i]$，（用f[i, j] 会比f[j, i]慢50%左右，会TLE。**总结：定义数组的原则：把内层循环用到的那一维放到定义数组的后面去，越靠内层的维数越往数组后面放，这样能提高运行效率，防止卡常**）
>
> 1. f[j, i]：j个饲养员，取前i只小猫的最小花费
> 2. 状态计算：$f(j, i) = min\{f(j - 1,k) + a_i\times (i-k)-(Sum_i-Sum_k)\}$
>
> 整理，得 $f(j,i) = f(j-1,k) - a_i\times k+Sum_k + a_i\times i - Sum_i$
>
> 将与`k`有关提取出来，得 $f(j-1,k)+Sum_k = a_i\times k + f(j,i)-a_i\times i + Sum_i$
>
> 其中，斜率$k = a_i$单调递增，截距$b=f(j,i)-a_i\times i + Sum_i$与$f(j,i)$成正相关。（与上题一模一样）

- [代码](E:/codes/C++/AcwingTest/运输小猫.cpp)

****

