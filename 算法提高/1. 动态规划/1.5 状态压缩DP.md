# 状态压缩DP

分为两大类：棋盘式（基于连通性） 和 集合式

这两大类都是基于“[递归实现指数型枚举](https://www.acwing.com/problem/content/94/)”这道题。

## 棋盘式

#### 1. [蒙德里安的梦想](https://www.acwing.com/problem/content/293/)

[基础课](../算法基础/19计数类DP)讲过。

****

#### 2. [国王](http://ybt.ssoier.cn:8088/problem_show.php?pid=1592)

- [思路](https://www.acwing.com/solution/content/56348/)

**第i层怎么摆只跟上一层（第i-1层）有关。**因此可以考虑状态压缩DP。

> 状态表示：f[i, j, s]
>
> 1. 集合：表示所有只摆在前i行，且已经摆完了j个国王，并且第i行摆放的状态是s的所有方案的集合。（其中s是一个二进制数，1表示当前位置摆放了国王）
> 2. 属性：Count
>
> 状态计算——划分依据：上一层的状态。
>
> 需要满足两个条件：1. 第i-1层内部不能有两个1相邻；2. 第i-1层和第i层也不能相互攻击到。
>
> 怎么判断相邻两行之间不能互相攻击到呢？分别用a，b表示第i-1行和第i行的状态，需要满足：1. $(a\&b)==0$；2. $(a | b)不能有两个相邻的1$。

当满足条件时，这个集合：已经摆完了前i行，并且第i行的状态是a，第i-1行的状态是b，且已经摆了j个国王的所有方案。**等价于：**

已经摆完了前i-1行，并且第i-1行的状态是b，且已经摆了j-count(a)个国王的所有方案。==f[i - 1, j - count(a), b]==（状态转移） 

<img src="1.5 状态压缩DP/image/image-20231130192544644.png" alt="image-20231130192544644" style="zoom:80%;" />

- [代码](E:/codes/C++/AcwingTest/国王.cpp)

****

#### 3. [玉米田](https://www.acwing.com/problem/content/329/)

- [思路](https://www.acwing.com/solution/content/56822/)

**与上一题不同之处是这题是十字型，而不是井字型。**

> 状态表示：f[i, s]
>
> 1. 集合：所有已经摆完前i行，并且第i行的状态是s的所有摆放方案的集合
> 2. 属性：Count
>
> 状态计算：以第i-1行的状态来进行划分。
>
> ###### 需要满足：1. a,b的二进制表示中不包含连续的两个1；==2. (a & b) == 0==
>
> 当条件满足时，这个集合：已经摆完前i行，且第i行的状态是a，第i-1行的状态是b的所有摆放方案。可以映射成：已经摆完前i-1行，且第i-1行的状态是b的所有方案。==f[i - 1, b]==

<img src="1.5 状态压缩DP/image/image-20231130202558020.png" alt="image-20231130202558020" style="zoom: 80%;" />

- [代码](E:/codes/C++/AcwingTest/玉米田.cpp)

****

#### 4. [炮兵阵地](https://www.acwing.com/problem/content/294/)

这一题是上一题的扩展题。

**与上一题的区别**：1. 射程由一格扩大成2格；2. 问题由求方案数变成了求最大摆放数量

- 思路

**状态表示新增一维用来表示上上行的状态，并且属性变成Max。**

>状态表示：f[i, j, k]
>
>1. 集合：所有已经摆完前i行，且第i-1行的状态是j，第i行的状态是k的所有摆放方案的集合
>
>2. 属性：Max
>
>状态计算：
>
>第i-1行状态是a，第i行状态是b，第i-2行的状态是c。
>
>则需要满足：1. ((a & b) | (a & c) | (b & c)) == 0；2. ((g[i - 1] & a) | (g[i] & b)) == 0。
>
>时间复杂度分析：$n·2^m·2^m·2^m=100\times 2^{30}=10^{11}$，但是本题的限制很强，因此，有效状态数量很少，时间复杂度实际上到不了那么高，而且还很低，完全能AC。

<img src="1.5 状态压缩DP/image/image-20231130210405515.png" alt="image-20231130210405515" style="zoom: 67%;" />

- [代码](E:/codes/C++/AcwingTest/炮兵阵地.cpp)

****

## 集合式

#### 1. [最短Hamilton路径](https://www.acwing.com/problem/content/93/)

基础课讲过。

****

#### 2. [毕业旅行问题](https://www.acwing.com/problem/content/733/)

- 思路：与`最短Hamilton路径`基本一样。

`最短Hamilton路径`求的是从0~n-1的路径，本题求的是从0到任一点结束的路径。

- [代码]()

****

#### 3. [愤怒的小鸟](https://www.acwing.com/problem/content/526/)

- 思路

抛物线方程：$y=ax^2+bx+c\quad(a<0且c=0)$

$\therefore y = ax^2+bx$ 	只需两点即可确定一条抛物线，且这两点的横坐标不相等，即$x_1\ne x_2$。

这道题一共有$n$个点，因此，最多会有$n^2$条抛物线。我们可以预处理出来这$n^2$条抛物线，并且预处理出来这$n^2$条抛物线每条都能覆盖的点。

那本思路就是：已知$n^2$条抛物线以及每条所能覆盖的点，求出最少需要选择多少条抛物线使得所有的点都被覆盖一次。（**经典的重复覆盖问题**）

> ==重复覆盖问题的模型==：给定一个01矩阵，让我们选择尽量少的行，可以使得每一列都至少包含一个1。
>
> ==精确覆盖问题的模型==：给定一个01矩阵，让我们选择尽量少的行，可以使得每一列都有且只有一个1。
>
> 这两个模型的应用很广：例如，`八皇后`和`数独`就是经典的精确覆盖问题。
>
> 这两种模型目前都已经存在最优的解法：Dancing Links（十字链表），可以优化dfs过程，但是时间复杂度还是指数级别的，但是很难写。

但是我们要写的是状态压缩DP，可以实现与Dancing Links类似的一个效果。思路就是用集合类型的状态压缩DP来优化我们的dfs。

**bfs思路：**

```c++
int dfs(int state) // state存的是当前哪些列已被覆盖
{
    if (state 已经包含所有列) return 0;
    int res = INF;
    任选没有被覆盖的一列x
    枚举所有能覆盖x的抛物线
    	更新一下state -> new_state
        res = min(res, dfs(new_state) + 1);
    return res;
}
```

==状态压缩DP优化：==

```c++
// 用f[state]存一下state，避免重复计算。
// x, path[x][j], new_state = state | path[x][j]
void dfs(int state, int cnt) // state存的是当前哪些列已被覆盖，cnt为当前已经用了多少条抛物线
{
    if (state 已经包含所有列) ans = min(ans, cnt); return;
    任选没有被覆盖的一列x
    枚举所有能覆盖x的抛物线
    	更新一下state -> new_state
        dfs(new_state, cnt + 1);
}
```

**如何由两点确定一条抛物线？**

<img src="1.5 状态压缩DP/image/image-20231202002509648.png" alt="image-20231202002509648" style="zoom:67%;" />

- [代码](E:/codes/C++/AcwingTest/愤怒的小鸟.cpp)

****

#### 4. [宝藏](https://www.acwing.com/problem/content/531/)