# 数位DP

- 难度较高，类似数学中的计算题，需要严谨的思路，一步错步步错。但是这种题的做法比较统一，包括思维和代码上都基本相同。

数位DP类型题目的经典考法：求某一个区间中满足某种性质的数的个数。

- 数位DP的技巧：

> 技巧1：[X, Y] => f(Y) = f(X - 1) 【解释：利用前缀和技巧，即用f(N)表示从1~N当中满足性质的数的个数，那么从X到Y之间满足性质的个数f([X, Y])就等于f(Y)减去f(X - 1)】
>
> **技巧2**：从==树==的角度去考虑数位DP问题。

#### 1. [度的数量]()

<img src="image/1.8 数位DP/image-20231207172209983.png"/>

- 思路

基本题意：把X和Y之间的数转换成B进制，从中找出只包含K个1的数字的个数就是答案。

样例解释：<img src="image/1.8 数位DP/image-20231207173037829.png" alt="image-20231207173037829" style="zoom:67%;" />

>  X范围：$0\sim 2^{31}$，暴搜肯定会超时，思考如何优化？

利用技巧1和技巧2，$N=a_{n-1}a_{n-2}\cdots a_0$ 。利用树的方式考虑：

<img src="image/1.8 数位DP/image-20231207175717227.png" alt="image-20231207175717227" style="zoom:80%;" />

假设N=76543210，目标是找到0~N中填K个1的数的个数。

先考虑最高位，分为两大类：

1.  最高位的数不是7，再分情况讨论。
   1. 若最高位填的不是1，则剩下7位中需要有k个1，方案数为$C_7^k$。
   2. 若最高位填的是1，则剩下7位中只能填k-1个1，方案数为$C_7^{k-1}$。
2.  最高位的数是7，再去考虑次高位，继续分为两大类：
    1.  次高位的数不是6，再分情况讨论。
        1.  若次高位不是1，方案数为$C_{n-2}^{k'}$。
        2.  若次高位是1，方案数为$C_{n-2}^{k'}$。（注意这里的$k'$是根据当前的上一位（这里指最高位）是否为1来取值，若为1则$k'=k-1$，否则$k'=k$）
    2. 最高位的数是6，…… 。

以此类推，直到考虑到最低位。


最终的方案数 = 左边所有叶子节点的方案数 + 最低位的方案数。（即所有叶子节点的方案数）

> 求组合数的公式：$C_a^b=C_{a-1}^{b-1}+C_{a-1}^{b}$

详细请见代码。

- [代码](E:/codes/C++/AcwingTest/度的数量.cpp)

****

- 第二种思路：记忆化搜索（更简单）

具体思路参考：https://www.acwing.com/solution/content/66855/

详细请见代码。

- [代码](E:/codes/C++/AcwingTest/度的数量_记忆化搜索.cpp)

****

#### 2. [数字游戏](http://ybt.ssoier.cn:8088/problem_show.php?pid=1586)

- 思路

先求0~N当中不降数的个数。与上一题的分析方式类似。

<img src="image/1.8 数位DP/image-20231207230643929.png" alt="image-20231207230643929" style="zoom:80%;" />

> 状态表示：f[i, j]
>
> 1. 集合：所有最高位是j，且一共有i位的不降数的集合
> 2. 属性：Count
>
> 状态计算：
>
> 所有集合的最高位已经固定（为j），后面的i-1位是不固定的，集合划分的依据是后面那一位的填法，可以填j, j+1, j+2, ..., 9中的一个，根据后面那一位（即第二位）的填法可以划分成若干类，假设第二位填的是k，因为最高位固定为j，那么可以去掉最高位，就变成了以最高位为k，且一共有i-1位的不降数的集合。所以，$f[i, j] = \sum_{j}^{9}f[i - 1, k])$。

<img src="image/1.8 数位DP/image-20231207231943222.png"/>

与上一题的不同之处：求左侧集合的方案数使用的是递推，而不是上一题中的求组合数。

- [代码](E:/codes/C++/AcwingTest/数字游戏.cpp)

****

#### 3. [Windy数](http://ybt.ssoier.cn:8088/problem_show.php?pid=1587)

- 思路

>  注意：本题要求不包含前导零，需特判掉前导零。

其他的思路与上一题类似。注意最高位不能填0！

<img src="image/1.8 数位DP/image-20231208102715230.png" alt="image-20231208102715230" style="zoom:80%;" />

状态表示与上一题相同。状态计算变成了：$f[i, j]=\sum_{k=0}^9f[i-1,k]（其中|j -k|\ge2）$

- [代码 ](E:/codes/C++/AcwingTest/Windy数.cpp)

****

#### 4. [数字游戏II](http://ybt.ssoier.cn:8088/problem_show.php?pid=1588)

- 思路

> 难点：预处理（数位DP的本质就是预处理上的DP，而不是求）

> 状态表示：f[i, j, k]表示总共有i位数，且最高位是j，且各位数之和模于N的余数是k的数的个数。
>
> 状态计算：$f[i,j,k]+=f[i-1,x,(k-j)\mod N]（其中x为第i-1位填的数字）$

<img src="image/1.8 数位DP/image-20231208112153433.png" alt="image-20231208112153433" style="zoom:80%;" />

- [代码](E:/codes/C++/AcwingTest/数字游戏II.cpp)

****

#### 5. [不要62](http://ybt.ssoier.cn:8088/problem_show.php?pid=1589)

- 思路

求的是不包含62和4的数字个数。如果只包含一个字符串，可以用KMP来做，也可以用《设计密码》这道题里的思路来做，如果包含两个字符串，就可以考虑用数位DP来做。这种类型的题还可以结合Tire+AC自动机一起考，题目：《修复DNA》。

> f[i, j]表示所有一共有i位，且最高位是j的不包含62和4的数的个数
>
> 状态计算：
>
> f[i, j] += f[i - 1, k]。需要满足：① $j, k \ne 4$	②$jk\ne 62$

<img src="image/1.8 数位DP/image-20231209113749253.png" alt="image-20231209113749253" style="zoom:80%;" />

- [代码](E:/codes/C++/AcwingTest/不要62.cpp)

****

#### 6. [恨7不成妻](http://ybt.ssoier.cn:8088/problem_show.php?pid=1590)（困难）

- 思路

本道题所需要满足的性质比较复杂。

①每一位数字不能是7

②每一位数加起来的和不能是7的倍数

③这个数不能是7的倍数

- 本题的难点在于最终求的不是满足性质的数的个数，而是求满足性质的数的平方和。

> f[i, j, a, b]表示总共有i位，最高位是j，且这个数模7的余数是a，各位数之和模7的余数是b的所有数的平方和。

<img src="image/1.8 数位DP/image-20231209171028204.png" alt="image-20231209171028204" style="zoom:80%;" />

> 状态计算：$f[i, j, a, b] += f[i - 1, k, a - j \times 10^{i-1}, b - j]$

要想推出平方和，就必须记录当前的最高位j当前所在位数以及j后面的那一串数字的和以及它们的平方。

<img src="image/1.8 数位DP/image-20231209171818698.png" alt="image-20231209171818698" style="zoom:80%;" />

详细思路参考：https://www.acwing.com/solution/content/67450/

- [代码](E:/codes/C++/AcwingTest/恨7不成妻.cpp)

****

