# 单源最短路

**单源最短路主要分为两大类：**

1. 边权均非负
   1. 朴素Dijkstra
   2. 堆优化Dijkstra
2. 有负权边
   1. Bellman-Ford
   2. SPFA

- **图论的题目难点在于问题的转换和抽象。**

****

## 简单应用

- 本小节主要讲图论问题的一般建图方式。

> 如何把一个问题转换成图论的问题才是关键，只要能够转换，就可以直接默写图论的代码模板速A了。

### 1. [热浪](http://ybt.ssoier.cn:8088/problem_show.php?pid=1379)

- 思路

最简单的单源最短路模型。根据题目所给的范围选择使用的算法，可以发现3种算法：`朴D`、`优D`、`spfa`都可以过，因此选择一个最熟悉的写就可以了。

- [代码](E:\codes\C++\AcwingTest\热浪.cpp)

****

### 2. [信使](http://ybt.ssoier.cn:8088/problem_show.php?pid=1376)

- 思路

本题本质上是一个“广播”模型，每个点接收到信息后会立即向与该点有边的点发送广播（存在反向广播）。求整个网络所有点都接收到信息共需要多少时间？

**核心**：对于每个点来说，它接收到信的时间就是它到指挥部的最短路径。

**其实就是求起点到所有其他点的最短距离中的最大值。**

- 由于本题的`N`很小，因此完全可以用`Floyd`算法来做，因为`Floyd`算法的代码很短。

- [代码](E:\codes\C++\AcwingTest\信使.cpp)

****

### 3. [香甜的黄油](https://www.acwing.com/problem/content/1129/)

- 思路

抽象成图论问题：先设定一个起点，然后算一下每头牛到该点的最短距离之和作为该点的花费。最后枚举每个点作为起点，找出其中花费最小的点作为答案输出。

因此，本题实际上是一个多源汇最短路问题。标准做法是`Floyd`，但是本题大概率会T，怎么优化呢？

① `朴D`：$O(n^3)$，显然也不能用。

② `优D`：$O(n\times m\log n)$，约等于$1450\times 800 \times \log 800 \approx 11600000$，可以AC。

③`spfa`：$O(nm)$，差不多$800\times 1450 = 1160000$，可以AC。需要注意spfa有概率被卡。

- [代码](E:\codes\C++\AcwingTest\香甜的黄油.cpp)

****

### 4. [最小花费](http://ybt.ssoier.cn:8088/problem_show.php?pid=1344)

- 思路

求A最少需要发多少钱，使得B可以收到100块。其中`A->B`的转账路线是由A决定的。

抽象模型：将手续费看作是边上权重$w(0<w\le 1)$，使得$d(y)=d(x)·w$。因此从A走到B，等价于$d(B) = d(A)·w_1·w_2 \cdots w_k$，求$d(A)$的最小值使得$d(B)=100$，等价于让$w_1w_2\cdots w_k$最大，因此就是求从A走到B的所有路径中**乘积最大**的那条路径，特别像最短路问题（求总和最小的一条路径）。 

- 要使得乘积最大，应该怎么做呢？

$\log (w_1w_2\cdots w_k) = \log w_1 + \log w_2 + \cdots + \log w_k$，由于$log$函数单调递增，因此要想使$w_1w_2\cdots w_k$，等价于让$\log (w_1w_2\cdots w_k)$ 最大，即让$\log w_1 + \log w_2 + \cdots + \log w_k$最大，由于$0<w\le 1$，因此$\log w_i \le 0,i\in [1, k]$，相当于求从A走到B使得$\log w_i$之和最大，对每个$\log w_i$取相反数，使得每条边都是非负边，此时就等价于求`A->B`的最短路径了。**所以这道题的本质就是：给我们一个边权都大于等于0的无向图，求出从起点走到终点的最短路径。**

> **注意：**
>
> 由于本题有个限制：$0<w<1,即 \log w_i \ge 0$，因此可以做到每条边权都是非负的。所以本题既可以用`朴D、优D`来做，也可以用`spfa`来做。
>
> 如果没有这个限制，就意味着每条边的权重可正可负，此时就只能用`spfa`来做了。

- 在代码的具体实现中，**直接用乘法替换加法即可**，没必要真正用`log`来表示边权。

- [代码](E:\codes\C++\AcwingTest\最小花费.cpp)

****

### 5. [最优乘车](https://www.acwing.com/problem/content/922/)

- 思路

抽象模型：把每个车站看作是一个点，可以做出下图，图中每条边权都是1。

<img src="image/3.1 单源最短路/image-20240102233347964.png" alt="image-20240102233347964" style="zoom:80%;" />

其中每条单程路线分别为：`2->1->3->5`、`4->7->3->6`、`6->7`。

这样就转换成了求从起点到终点的最短路径问题了。

- 对于每条公交路线，对每个点它之后能够到达的每一个点都连一条权重为`1`的边，表示从当前这个点坐到那个点只需要搭一趟车。

- 最终答案：换乘次数 = 从起点坐到终点最少需要坐的车数 - 1
- 特判：若起点等于终点，坐车次数和换车次数都是0
- 由于本题边权都是1，因此直接写一个BFS就可以了，不用写那么麻烦的Dijkstra和spfa。

- [代码](E:\codes\C++\AcwingTest\最优乘车.cpp)

****

### 6. [昂贵的聘礼](http://poj.org/problem?id=1062)

- 思路

样例解释：

<img src="image/3.1 单源最短路/image-20240103214430923.png" alt="image-20240103214430923" style="zoom:80%;" />

先花50块买`物品4`，再用`物品4`+200块换`物品3`，再用`物品3`+5000块换`物品1`。总花费：5250块。

抽象模型：找出起点和终点。终点很简单，就是目标物品（1号物品），起点呢？

**建图**：<img src="image/3.1 单源最短路/image-20240103214815677.png" alt="image-20240103214815677" style="zoom:100%;" />

**构造一个虚拟源点`S`**：`S`为虚拟源点，表示直接买。

我们可以发现：**原问题中任何一种购买策略都可以对应一条从`S`走到`1`的路线，反过来，任何一条购买方式都可以对应一条从S走到1号点的路径。两者一一对应。**购买花费恰好等于从`S`到`1`号点的距离之和，因此求的就是从`S`到`1`号点的最短路径。

- 考虑等级限制该怎么做呢？

很简单，由于等级限制最多只有100，因此可以暴力枚举每个等级区间，每个区间更新一下答案即可。因为区间最多只有100个，节点个数也只有100个，因此`朴D`就能过。

- [代码](E:\codes\C++\AcwingTest\昂贵的聘礼.cpp)

****

### 7. 其他应用题

- [最短距离](https://www.acwing.com/problem/content/description/1490/)（虚拟源点，优D）
- [奶牛回家](https://www.acwing.com/problem/content/1377/)（spfa）
- [Dijkstra序列](https://www.acwing.com/problem/content/description/4278/)（朴D）
- 

****

## 综合运用

本小节主要讲**单源最短路问题和其他算法的结合**。

其他算法主要包括：DFS、二分、DP、拓扑排序

直接看题目。

### 1. [新年好](http://ybt.ssoier.cn:8088/problem_show.php?pid=1500)（最短路+DFS）

- 思路

> 本题N范围50000，M范围$10^5$。

考虑暴力怎么做，一共五个亲戚`a b c d e`，因此有$5!$种拜访顺序。

当我们顺序确定之后，它就是一个单源最短路问题，求一下拜访序列中相邻两个点之间的最短距离之和即可。用`spfa`做的时间复杂度为$5! \times 5 \times O(m) = 6 \times 10^7$，但是`spfa`并不是稳定的$O(m)$时间复杂度，因此很有可能会T。

- 考虑怎么优化？

**调整代码的顺序即可。**刚刚的做法是先暴搜，再求5次单源最短路。

我们可以调整顺序：先预处理`1 a b c d e`这6个点到其他亲戚点的最短路径（做6次`spfa`算法），再去做暴搜，暴搜过程中对于每个点的距离直接查表即可，而不需要在暴搜的过程中求最短路。时间复杂度：$6\times O(m) + 5!$。这样就能A了。

- [代码](E:\codes\C++\AcwingTest\新年好.cpp)
- Update: `spfa`寄了，换`优D`。

****

### 2. [通信线路](https://www.acwing.com/problem/content/342/)（最短路+二分）

- 思路

思考二分性质：区间：`l = 0, r = 1e6 + 1`

每次枚举`mid = l + r >> 1`，将大于`mid`的边权赋值为`1`，小于等于`mid`的边权赋值为`0`

这样从`1->N`的路径和`sum`表示经过的边至少有`sum`条花费大于`mid`的边。

假设至少经过`y`条，那么性质的结果就是`y <= k`是否成立。

换言之，求出从1走到N，最少经过的长度大于`mid`的边的数量是否小于等于`k`。

- 本题长度L的范围是`[1, 100000]`，那么二分的区间为什么取`[0, 100001]`呢？

从实际含义出发，考虑答案是否可能取到0？是可能取到0的。那为什么右端点取100001呢？如果1和N不连通，那么若二分返回的答案是100000，我们是不能判断1和N是不连通的，因为100000也有可能作为答案输出，因此需要取100001来表示无解的情况。

- 如何求出从1走到N，最少经过的长度大于`x`的边的数量是否小于等于`k`？

  1. 先求出从1到N最少经过几条长度大于`x`的边。可以将所有边分类：若边长大于`x`，则边权看成1，否则边权是0。

  2. 可以用双端队列BFS来求从1到N的最短路（如果一个图中的边权只有0或1，那么求最短路可以用双端队列广搜来做，时间复杂度是线性的）。

- 时间复杂度：$O((N + P)\times \log L) \approx 200000$。

<img src="image/3.1 单源最短路/image-20240104002002372.png" alt="image-20240104002002372" style="zoom:100%;" />

- [代码](E:\codes\C++\AcwingTest\通信线路.cpp)

****

### 3. [道路与航线](https://www.acwing.com/problem/content/344/)（最短路+拓扑序）

- 思路

有两种路线：一种是`道路（双向、边权非负）`，另一种是`航线（单向、边权可正可负、且无环）`。

求`S`到其他所有点的最短距离，点数25000，边数50000。注意：本题`spfa`会被卡。

> 已知：
>
> 1. 如果边权非负，那么可以用Dijkstra算法，时间复杂度是$O(m\log n)$。
> 2. 如果是拓扑图，那么不管边权是正是负，均可用拓扑序扫描，时间复杂度是线性的。

<img src="image/3.1 单源最短路/image-20240104134341631.png" alt="image-20240104134341631" style="zoom:80%;" />

先把**只含道路**的每个点看作一个团（连通块），再把每个团看作一个点，点与点之间的边是航线（单向），这样就构成了一张拓扑图，**然后按照拓扑序用Dijkstra算法处理每个团**。这样的话，时间复杂度就是$O(m\log n + (n+m))=O(m\log n)$。 

- 算法流程

<img src="image/3.1 单源最短路/image-20240104135222603.png" alt="image-20240104135222603" style="zoom:80%;" />

- [代码](E:\codes\C++\AcwingTest\道路与航线.cpp)

> 当DP问题的依赖关系不具有拓扑序，那么我们可以用最短路的方式来求DP的最优解的。
>
> 例如：
>
> `f[2] = min(f[1] + 1, f[4] + 1)`
>
> `f[3] = f[2] + 1`
>
> `f[4] = f[3] + 1`
>
> `f[5] = f[4] + 1`
>
> 求`f[1] -> f[5]`的最短路径即可。
>
> 当然也可以用高斯消元来求解。
>
> <img src="image/3.1 单源最短路/image-20240113133855896.png" alt="image-20240113133855896" style="zoom:80%;" />

****

### 4. [最优贸易](https://www.acwing.com/problem/content/343/)（最短路+DP）

- 思路

本题做法不唯一，可以用`分层图`的做法来做。

但是这里我们用`DP`的思路来看，我们要求的是所有从1到n的路径中先买再卖的最大收益路径。

- 集合：所有从1走到n的路径。

- 集合划分（不漏）：买和卖的分界点，即在分界点处或分界点之前买，在分界点处或分界点之后卖。可以划分成n类，所有分界点是1号点的归为第一类，是2号点的归为第二类，……，是n号点的归为第n类。
- 显然是会有重复的，例如：在这条路径`1(买)->2->3->4(卖)`中：分界点可以是1，2，3，4号点中任一点。虽然会有重复计算，但是这种划分方式一定可以做到不遗漏！

- 如何求出所有以k为分界点的所有路线的最大值？

思路：分段。先求一下从1走到k的过程中买入的最小值$d_{min}[k]$（表示所有可以从1走到k的所有点的权值的最小值），再求一下所有从k走到n的过程中卖出的最大值$d_{max}[k]$（表示所有可以从k走到n的所有点的权值的最大值）。最终答案就是$d_{max}[k] - d_{min}[k]$。

$d_{min}[k] = min\{d_{min}[s_1],d_{min}[s_2],\cdots,d_{min}[s_t],w_k\}$。本质上就是一个dp的过程。但是本题是存在环的，因此不能用dp来做，需要转换成最短路模型来求解。

- Dijkstra：判断是否可用：当我们从堆中取出来一个点`ver`时，若该点的最短距离之后就不会再被更新了，那么就可以用Dijkstra，否则不能用。而本题`ver`是有可能被更新的，因此不能使用Dijkstra。
- SPFA：泛用性很广。本质上是Bellman-Ford算法（本质是DP）。在本题中可以使用。

- $d_{max}[k]$怎么求呢？从n号点再反向做一遍`spfa`即可。

- [代码](E:\codes\C++\AcwingTest\最优贸易.cpp)

****

## 扩展应用

### 1.[选择最佳线路](https://acm.hdu.edu.cn/showproblem.php?pid=2680)

- 思路

在**多个起点**中选择一条到达**一个终点**的最短路径。（任选起点）

解法1：把所有边建成反向边，然后把终点当成起点，求出终点到达所有起点的最短路径。（但是这种方法不好扩展）

**解法2**：在任选起点的情况下，求出其到达每个点的最短路径（多个起点，多个终点）。Floyd是求出任意两点间的距离，但是这题终点是固定的。

直接枚举起点，跑一遍最短路，是会TLE的。因此需要优化。

- 优化思路：建立一个**虚拟源点**。在虚拟源点与每个起点间连一个长度是0的边。
- 注意：边数范围1<=M<=20000，而虚拟源点需要多开1000条边，因此存储边的数组范围需要多开1000。尽量开多一点。

- [代码](E:\codes\C++\AcwingTest\选择最佳线路.cpp)

****

### 2.[拯救大兵瑞恩](https://www.luogu.com.cn/problem/P4011)

- 思路

<img src="image/3.1 单源最短路/image-20240331160008058.png"/>

状态表示：`d[x, y, state]`表示所有从起点走到`(x, y)`这个格子，且当前已经拥有的钥匙是`state`的所有路线的集合。（其中state是一个二进制数，类似状压dp）

<img src="image/3.1 单源最短路/image-20240331160715991.png" alt="image-20240331160715991" style="zoom:80%;" />

不能用dp来做（dp可以看作是一个特殊的最短路问题，一个在拓扑图上的最短路问题），因为有环存在。所以需要把dp转成最短路来做。

- **把这两种转移方式看作两种边，第一种边权是0，第二种边权是1。（dp转最短路）**

<img src="image/3.1 单源最短路/image-20240331160906038.png" alt="image-20240331160906038" style="zoom:80%;" />

- 最终答案在$d(N, M, 0\sim 2^{p-1})$中取最小值。

- 因为边权只有0或1，因此可以使用**双端队列BFS算法**（时间复杂度稳定线性）。

- 所以这道题的思路就是：**最短路 $\to$ DP $\to$ 最短路**。

- [代码](E:\codes\C++\AcwingTest\拯救大兵瑞恩.cpp)

****

### 3.[最短路计数](http://ybt.ssoier.cn:8088/problem_show.php?pid=1499)

大致题意：求一个点到其他每个点的最短路有几条。输出N行，每行表示顶点1到顶点i的最短路有几条。

- 思路

回顾一下DP求最优解个数的思路：

1. 先求出**全局最小值**是多少。用`f[i]`表示
2. 再分别求出每个子集中等于该**全局最小值**的元素个数。`cnt[i]`表示每个子集当中全局最小值的元素个数的和。

这题做法类似DP。用`dist[i]`表示从1号点到其他每个点的最短路的集合。`cnt[i]`表示从1到i的最短路径的条数。

- 如何让最短路问题中有**拓扑序**？

`最短路树（最短路拓扑图）`：存一下这个点是由哪个点更新的。给所有点保留一个前趋。`dist[j] = dist[t] + w[i]`，那么j的前趋就是t。若j的前趋有多个，存其中任意一个。这样就构成了一棵树。该最短路径树上一定不能存在权值为0的环，否则就无解了。那么如果把能更新的边的前趋全部连起来的话，就能够得到一个拓扑图了。

<img src="image/3.1 单源最短路/image-20240406142014110.png" alt="image-20240406142014110" style="zoom:80%;" />

- [代码](E:\codes\C++\AcwingTest\最短路计数.cpp)
